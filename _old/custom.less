//Less Mixin继承 CSS命名空间 默认值 arguments参数
#xiaoShaoSpace {
  .roundedCorners(@border-size: 1px; @border-color: #BD68D9; @radius:5px) {
    border: @border-size solid @border-color;
    -moz-border-radius: @radius;
    -webkit-border-radius: @radius;
    border-radius: @radius;
    text-align: center;
  }
  .boxShadow(@x:0; @y:0; @blur:1px; @color:#E5E5E5) {
    -moz-box-shadow: @arguments;
    -webkit-box-shadow: @arguments;
    box-shadow: @arguments;
  }
}

#otherSpace {
  .boxSize(@box-width: 100%; @box-height: 100%) {
    width: @box-width;
    height: @box-height;
  }
}

.xx-header {
  #xiaoShaoSpace > .roundedCorners;
  #xiaoShaoSpace > .boxShadow;
  #otherSpace > .boxSize;
}

.xx-footer {
  #xiaoShaoSpace > .roundedCorners(2px, #ff3366, 10px);
  #xiaoShaoSpace > .boxShadow(2px, 2px, 3px, #00ff00);
  #otherSpace > .boxSize(50%, 50%);
}

// Mixin的参数列表使用分号作为分隔符更好(目前看来是和逗号无异)
.mixin-test-1(@padding; @position; @rgb) {
  padding: @padding;
  position: @position;
  box-shadow: @rgb;
}

.xx-mixin-test-1 {
  .mixin-test-1(1px 2px 3px 4px; relative; rgb(255, 0, 16));
}

// 相同名称和参数数量的Mixin是合法的, Less会使用全部可以使用的属性+参数（包括default）来编译
.mixin-test-2(@color) {
  color: @color;
}

.mixin-test-2(@color; @padding: 2px) {
  background-color: @color;
  padding: @padding;
}

.mixin-test-2(@color; @padding; @margin: 5px) {
  border-color: @color;
  padding: 0 @padding;
  margin: @margin;
}

.xx-mixin-test-2 {
  .mixin-test-2(#ff3399);
}

// 使用命名参数来自定义传参顺序
.xx-mixin-test-2-1 {
  .mixin-test-2(@padding: 10px; @color: #449900);
}

// 接受数量不定的参数
/*
    .mixin() {                 //不接受参数
    .mixin(@a) {           //接受1个参数
    .mixin(@a: 1) {       //接受0或1个参数
    .mixin(...) {              //接受0至N个参数
    .mixin(@a: 1; ...) {   //接受0至N个参数
    .mixin(@a; ...) {      //接受1至N个参数
*/
.mixin-test-3(@first; ...) { //接受1至N个参数
  background: @arguments;
}

.xx-mixin-test-3 {
  .mixin-test-3(#ff4400)
}

// 变量之后带...表示将匹配的参数全部分配给这个变量
// .mixin-test-4(@padding; @rest...; @top)是SyntaxError
.mixin-test-4(@padding; @rest...) {
  padding: @padding;
  -webkit-box-shadow: @rest;
  -moz-box-shadow: @rest;
  box-shadow: @rest;
}

.xx-mixin-test-4 {
  .mixin-test-4(10px; 1px; 2px; 3px)
}

// Mixin的匹配模式(标志变量, 参数数量)
// 标志变量匹配
.turn(light; @color) {
  color: lighten(@color, 10%);
}

.turn(dark; @color) {
  color: darken(@color, 10%);
}

.turn(@_; @color) {
  display: block;
}

@action-1: light;
.light {
  .turn(@action-1; #888);
}

@action-2: dark;
.dark {
  .turn(@action-2; #888);
}

// 参数数量匹配
.change-color(@color) {
  color: @color;
}

.change-color(@color; @percentage) {
  color: fade(@color, @percentage);
}

.test-static {
  .change-color(#bb1100);
}

.test-fade {
  .change-color(#bb1100; 50%);
}

//Mixin中的变量都是可见的，可用于调用它的作用域中
.mixin-as-function-1() {
  @width: 100%;
  @height: 50%;
}

.caller-1 {
  .mixin-as-function-1();
  // 仅仅定义了参数
  width: @width;
  height: @height;
}

.mixin-as-function-2(@x; @y) {
  @average: (@x + @y) / 2
}

.caller-2 {
  .mixin-as-function-2(@y: 100px; @x: 200px);
  //返回计算结果
  padding: @average;
}

@xx-rules: { .xx-surface {
  @media (screen) and (max-width: 968px) {
    float: left;
  }
} };
// 将@xx-rules中的media提取出来
@xx-rules();
// 将@xx-rules中的media提取出来 同时与外层合并
@media (orientation: portrait) {
  @xx-rules();
}

// 传入到mobile-and-gt-ie9的rules是应用在mobile端和ie9+的css3规则
.mobile-and-gt-ie9(@rules) {
  @media screen and (max-width: 768px) { @rules();
  }
  html.gt-ie9 & { @rules();
  }
}

@css3-rules: { border-radius: 2px 4px; };
.header {
  position: absolute;
  // 为header添加mobile端和ie9+的特殊样式
  .mobile-and-gt-ie9(@css3-rules);
}

//条件mixin
.mixin-guard (@a) when (lightness(@a) >= 50%) {
  background-color: black;
}

.mixin-guard (@a) when (lightness(@a) < 50%) {
  background-color: white;
}

.mixin-guard (@a) {
  color: @a;
}

.mixin-guard-1 {
  .mixin-guard(#ddd)
}

.mixin-guard-2 {
  .mixin-guard(#555)
}

//条件css
@my-option: true;
.my-optional-style() when (@my-option = true) {
}

.my-optional-style();
// 循环（生成栅格系统）
.loop(@counter) when (@counter > 0) {
  .loop((@counter - 1)); // 递归调用自身
  width: (10px * @counter); // 每次调用时产生的样式代码
}

.loop-test {
  .loop(5); // 调用循环
}

// 栅格系统
.generate-columns(@n, @i: 1) when (@i =< @n) {
  .column-@{i} {
    width: (@i * 100% / @n);
  }
  .generate-columns(@n, (@i + 1));
}

.generate-columns(4);
// 多属性css rules merge( use + or +_ to decide useing which separator: comma or space )
.merge-css-rules() {
  box-shadow+: inset 0 0 10px #555;
  transform+_: scale(2);
}

.merge-css-rules-test {
  .merge-css-rules();
  box-shadow+: 0 0 20px black;
  transform+_: rotate(15deg);
}

// Parent Selectors
// &的典型的场景：生成重复的类名
.button {
  padding: 10px;
  &-ok {
    background-image: url("../img/chrome.png");
  }
  &-cancel {
    background-image: url("../img/firefox.png");
  }

  &-custom {
    background-image: url("../img/Safari.png");
  }
}

// &的典型的场景：css兼容性问题, 前置回退样式类
.css3-border-radius-headers {
  .css3-border-radius-menus {
    border-radius: 1px 2px 3px;
    .no-support-css3-border-radius & {
      background-image: url('../img/ie.png');
    }
  }
}

// &代表所有的父选择器
.grandfather {
  .father {
    // &代表 .grandfather .father
    & > & {
      color: red;
    }
    & & {
      color: green;
    }
    && {
      color: blue;
    }
    &, &ish {
      color: cyan;
    }
  }
}

// &可以用于生成一个逗号分割列表的所有可能的Selector排列
.row, .col, div {
  border-top: 2px solid #fff;
  & & {
    border-top: 0;
  }
}

// ------------------------------------------------
//Less CSS嵌套规则
#home {
  color: blue;
  width: 600px;
  height: 500px;
  border: outset;
  #top {
    border: outset;
    width: 90%;
  }
  #center {
    border: outset;
    height: 300px;
    width: 90%;
    #left {
      border: outset;
      float: left;
      width: 40%;
    }
    #right {
      border: outset;
      float: left;
      width: 40%;
    }
  }
}

//Less CSS伪元素规则
.alink {
  color: #ffa5a3;
  text-decoration: none;
  &:hover {
    color: black;
    text-decoration: underline;
  }
}

// 更多变量的使用方式: 类名 字符串 属性 变量名
@myBanner: xx-banner;
@imgURL: "../img";
@property: color;
@colorValue: #00eeee;
@colorVar: "colorValue";
.@{myBanner} {
  font-weight: bold;
  line-height: 40px;
  margin: 0 auto;
  background: url("@{imgURL}/chrome.png");
    @{property}: @@colorVar;
}

//lazy loading
.lazy-eval {
  width: @lazyVar;
  @lazyValue: 99%;
}

@lazyVar: @lazyValue;
@lazyValue: 10%;
// ------------------------------------------------
//Less Extend：避免在html class中添加多个类；替代Mixin减少css代码量
.main-content {
  color: #0b97c4;
}

// Extend方式-1：定义.main-content时会将.nav-content以同样的rules扩展
.nav-content {
  &:extend(.main-content);
  background: #00A000;
}

//Extend方式-2： 定义.main-content时会将.section-content以同样的rules扩展
.section-content:extend(.main-content) {
  background: #5890ad;
}

// Extend方式-1 是 Extend方式-2 的快捷方式: 为所有的选择器扩展
.nav-left-content, .nav-right-content {
  &:extend(.main-content);
  background: #bb1100;
}

// 扩展到多个选择器
.side-content {
  margin: 10px;
}

.code-content {
  padding: 5px;
}

.code-side-content:extend(.side-content, .code-content) {
  // .code-side-content:extend(.side-content):extend(.code-content)
  width: 500px;
  height: 200px;
}

// 所有的扩展都必须在选择器的尾部 .price:extend(.title):hover是错的
.title {
  text-align: center;
  color: #ff4400;
}

.price:hover:extend(.title) {
  text-align: left;
}

// 识别Less嵌套的嵌套规则
.rank {
  .tamll {
    color: #bb1100;
  }
  .taobao {
    color: #ff4400;
  }
}

.double-11, .double-12 {
  &:extend(.rank .tamll);
}

// 注意识别的是编译之后的css嵌套结构
.info {
  details & {
    position: absolute;
  }
}

.some-class:extend(details .info) {
}

// extend最后指定all时, 实现先替换再扩展, 继承部分
.contry.province.city,
.city.street {
  text-align: left;
}

.city {
  &:hover {
    display: block;
  }
}

.town:extend(.city all) {
  float: left;
}

// 插值选择器(带变量的选择器)不会匹配(双向的)
@var1: .src_1;
@{var1} {
  position: fixed;
}

.des_1:extend(.src_1) {
}

.src_2 {
  text-align: center;
}

.des_2:extend(@{var2}) {
}

@var2: .src_2;
// 但是给插值选择器附加extend是可以的
.src_3 {
  float: left;
}

@{var3}:extend(.src_3) {
}

@var3: .des_3;
// media中的extend扩展三原则
// 1.media声明内的extend也应该只匹配同一media声明内的选择器
// 2.media声明内的extend不会匹配嵌套media声明内的选择器
// 3.顶级extend匹配一切，包括media嵌套内的选择器
@media mobile {
  .des-in:extend(.src) {
  }

  // mobile域的extend
  .src { // extend(mobile域)匹配到同域下的
    position: absolute;
  }

  @media (min-width: 1023px) {
    .src { // extend(mobile域)会忽略它(嵌套media域)
      position: static;
    }
  }
}

@media surface {
  .src { // exten(mobile域)也会忽略它(surface域)
    position: fixed;
  }
}

.src { // extend(mobile域)会忽略它(顶级域)
  position: relative;
}

.des-top:extend(.src) {
}

// 顶级域的extend会匹配全部.src
// extend的重复扩展目前还没有解决！！
// 会在.level中扩展.level-3两次
.level-1 {
  color: #bb1100;
}

.level-2-1:extend(.level-1) {
  text-align: left;
}

.level-2-2:extend(.level-1) {
  text-align: right;
}

.level-3:extend(.level-2-1, .level-2-2) {
}